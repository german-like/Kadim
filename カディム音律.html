<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>和音ピアノ（fₙ = 220 × 3ⁿ⁄¹⁵）</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f5f5f5;
    }
    #keyboard {
      position: relative;
      height: 200px;
      margin: 20px auto;
      width: max-content;
    }
    .white-key {
      width: 40px;
      height: 200px;
      background: white;
      border: 1px solid #ccc;
      display: inline-block;
      position: relative;
      z-index: 1;
      box-sizing: border-box;
    }
    .black-key {
      width: 30px;
      height: 120px;
      background: black;
      position: absolute;
      top: 0;
      z-index: 2;
      color: white;
      font-size: 10px;
      text-align: center;
    }
    .pressed {
      background-color: #ffd700 !important;
    }
    .label {
      position: absolute;
      bottom: 5px;
      width: 100%;
      font-size: 12px;
    }
    #controls {
      margin-top: 20px;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
    }
  </style>
</head>
<body>
  <h1>🎹 和音ピアノ（fₙ = 220 × 3ⁿ⁄¹⁵）</h1>
  <div id="keyboard"></div>

  <div id="controls">
    <button onclick="startRecording()">⏺️ 録音開始</button>
    <button onclick="stopRecording()">⏹️ 録音停止</button>
    <a id="downloadLink" style="display:none" download="recording.webm">⬇️ 録音ダウンロード</a>
  </div>

  <div class="keyboard" id="keyboard"></div>

  <script>
    const f0 = 220;
    const step = Math.pow(3 , 1 / 15);
    const totalKeys = 31;
    const blackKeys = [2,6,10,14,17,21,25,29];
    const labels = ["Da","Na","Fi","Ke","Me","She","Ba","Ha","Se","Je","Ya","Wa","Cha","Pa","Tu"];
    const keyToIndex = {
      'a': 0,  's': 1,  'd': 2,  'f': 3,  'g': 4,
      'h': 5,  'j': 6,  'k': 7,  'l': 8,  ';': 9,
      'q': 10, 'w': 11, 'e': 12, 'r': 13, 't': 14,
      'y': 15, 'u': 16, 'i': 17, 'o': 18, 'p': 19,
      'z': 20, 'x': 21, 'c': 22, 'v': 23, 'b': 24,
      'n': 25, 'm': 26, ',': 27, '.': 28, '/': 29,
      '1': 30, '2': 31
    };

    let audioCtx, destination, mediaRecorder, recordedChunks = [];
    const activeOscillators = {};

    function initAudioContext() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        destination = audioCtx.createMediaStreamDestination();
        mediaRecorder = new MediaRecorder(destination.stream);
        mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          const link = document.getElementById("downloadLink");
          link.href = url;
          link.style.display = "inline";
        };
        startSilence();
      }
    }

    function startSilence() {
      const silentOsc = audioCtx.createOscillator();
      const silentGain = audioCtx.createGain();
      silentGain.gain.setValueAtTime(0, audioCtx.currentTime);
      silentOsc.connect(silentGain);
      silentGain.connect(destination);
      silentOsc.start();
    }

    function createKeyboard() {
      const keyboard = document.getElementById("keyboard");
      for (let n = 0; n < totalKeys; n++) {
        const isBlack = blackKeyIndices.includes(n);
        const key = document.createElement("div");
        const label = document.createElement("div");
        label.className = "label";
        label.textContent = keyLabels[n] || n;

        key.dataset.n = n;
        key.appendChild(label);

        if (isBlack) {
          key.className = "black-key";
          // 黒鍵を白鍵間に配置（左にずらす）
          const leftOffset = n * 41 - 10;
          key.style.left = `${leftOffset}px`;
        } else {
          key.className = "white-key";
        }

        key.addEventListener("mousedown", () => play(n));
        key.addEventListener("mouseup", () => stop(n));
        keyboard.appendChild(key);
      }
    }

    function play(n) {
      initAudioContext();
      const freq = f0 * Math.pow(3, n / 15);
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      gainNode.connect(destination);
      osc.start();
      activeOscillators[n] = { osc, gainNode };
      document.querySelector(`[data-n="${n}"]`)?.classList.add("pressed");
    }

    function stop(n) {
      const oscData = activeOscillators[n];
      if (oscData) {
        const { osc, gainNode } = oscData;
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
        osc.stop(audioCtx.currentTime + 0.2);
        delete activeOscillators[n];
        document.querySelector(`[data-n="${n}"]`)?.classList.remove("pressed");
      }
    }

    document.addEventListener("keydown", (e) => {
      const n = keyToIndex[e.key];
      if (n !== undefined && !(n in activeOscillators)) play(n);
    });

    document.addEventListener("keyup", (e) => {
      const n = keyToIndex[e.key];
      if (n !== undefined) stop(n);
    });

    function startRecording() {
      recordedChunks = [];
      mediaRecorder.start();
    }

    function stopRecording() {
      mediaRecorder.stop();
    }

    createKeyboard();
  </script>
</body>
</html>
